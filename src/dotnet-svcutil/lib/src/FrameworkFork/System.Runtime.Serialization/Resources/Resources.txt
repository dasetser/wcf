AbstractElementNotSupported=The element cannot have 'abstract' set to 'true'.
AbstractTypeNotSupported=The type cannot have 'abstract' set to 'true'.
AmbiguousReferencedTypes1=List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}
AmbiguousReferencedTypes3=List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}
AmbiguousReferencedCollectionTypes1=List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}
AmbiguousReferencedCollectionTypes3=List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}
AnnotationAttributeNotFound=Invalid '{0}' annotation in type '{1}' from namespace '{2}'. Attribute '{3}' not present.
AnonymousTypeNotSupported=Anonymous type in element '{0}' from namespace '{1}' is not supported.
AnyAttributeNotSupported='anyAttribute' is not supported.
ArrayExceededSizeAttribute=Array length '{0}' provided by Size attribute is not equal to the number of array elements '{1}' from namespace '{2}' found.
ArrayExceededSize=Array length '{0}' provided by the get-only collection of type '{1}' is less than the number of array elements found in the input stream.  Consider increasing the length of the array.
ArraySizeXmlMismatch=Array length '{0}' provided by Size attribute is not equal to the array length '{1}' read from XML data.
ArrayItemFormMustBe=Form for element '{0}' must be qualified.
ArraySizeAttributeIncorrect=Array Size '{0}' is not equal to the number of elements found '{1}'.
ArrayTypeCannotBeImported=Array type '{0}' in namespace '{1}' cannot be imported. {2}
ArrayTypeIsNotSupported=An internal error has occurred. '{0}[]' is not supported when generating code for serialization.
AssemblyNotFound=Assembly '{0}' is not found.
AttributeNotFound=XML '{2}' '{3}:{4}' does not contain expected attribute '{0}:{1}'. The deserializer has no knowledge of which type to deserialize. Check that the type being serialized has the same contract as the type being deserialized.
BaseTypeNotISerializable=One of its base types, '{0}' from namespace '{1}' is not ISerializable.
CLRNamespaceMappedMultipleTimes=CLR namespace '{2}' has already been mapped to data contract namespace '{0}'. It cannot be mapped to another data contract namespace '{1}'.
CallbackMustReturnVoid=Serialization Callback '{1}' in type '{0}' must return void.
CallbackParameterInvalid=Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.
CallbacksCannotBeVirtualMethods=Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.
CanOnlyStoreIntoArgOrLocGot0=An internal error has occurred. Data can only be stored into ArgBuilder or LocalBuilder. Got: {0}.
CannotComputeUniqueName=A unique name cannot be computed for '{0}' because there are already Int32.MaxValue types of with the same name.
CannotDeriveFromSealedReferenceType=Type with data contract name '{0}' in namespace '{1}' cannot be imported. Cannot derive from sealed referenced type '{2}'. 
CannotDeserializeForwardedType=NetDataContractSerializer cannot deserialize type '{0}' because it has been type forwarded from an assembly with a lesser permission set and there is no [TypeForwardedFrom] attribute indicating the origin of the type.
CannotDeserializeRefAtTopLevel=Cannot deserialize since root element references unrecognized object with id '{0}'.
CannotExportNullAssembly=Cannot export null assembly provided via '{0}' parameter.
CannotExportNullKnownType=Cannot export null type provided via KnownTypesCollection.
CannotExportNullType=Cannot export null type provided via '{0}' parameter.
CannotHaveDuplicateElementNames=The type contains two elements with the same name '{0}'. Multiple elements with the same name in one type are not supported because members marked with DataMemberAttribute attribute must have unique names.
CannotHaveDuplicateAttributeNames=The type contains two attributes with the same name '{0}'. Multiple attributes with the same name in one type are not supported.
CannotImportInvalidSchemas=Cannot import invalid schemas. Compilation on the XmlSchemaSet failed.
CannotImportNullDataContractName=Cannot import type for null XmlQualifiedName specified via parameter.
CannotImportNullSchema=Cannot import null XmlSchema contained in XmlSchemaSet specified via parameter.
CannotLoadMemberType=Cannot load member type '{0}'.
CannotSerializeObjectWithCycles=Object graph for type '{0}' contains cycles and cannot be serialized if reference tracking is disabled.
CannotSetMembersForReferencedType=Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Members cannot be added for this type since it cannot be modified.
CannotSetNamespaceForReferencedType=Existing type '{0}' specified via the referenced types collection has been referenced in the generated code. Cannot set namespace for this type since it cannot be modified.
CannotUseGenericTypeAsBase=Collection type cannot be generated for type '{0}' from namespace '{1}'. Cannot use a generic list type as a base type because the language does not support generic type references.
CharIsInvalidPrimitive=An internal error has occurred. Char is not a valid schema primitive and should be treated as int in DataContract.
CircularTypeReference=It contains a circular reference for type '{0}' from namespace '{1}'.
ClrTypeNotFound=The deserializer cannot load the type to deserialize because type '{1}' could not be found in assembly '{0}'. Check that the type being serialized has the same contract as the type being deserialized and the same assembly is used.
CollectionTypeCannotBeBuiltIn={0} is a built-in type and cannot be a collection.
CollectionTypeIsNotIEnumerable={0} does not implement IEnumerable interface.
CollectionTypeDoesNotHaveDefaultCtor={0} does not have a default constructor.
CollectionTypeDoesNotHaveAddMethod={0} does not have a valid Add method with parameter of type '{1}'.
CollectionTypeHasMultipleDefinitionsOfInterface={0} has multiple definitions of interface '{1}'.
CollectionTypeCannotHaveDataContract={0} has DataContractAttribute attribute.
CollectionMustHaveGetEnumeratorMethod=Collection type '{0}' does not have a valid GetEnumerator method.
CollectionMustHaveAddMethod=Collection type '{0}' does not have a valid Add method.
CollectionMustHaveItemType=Collection type '{0}' must have a non-null item type.
ComplexTypeRestrictionNotSupported=Complex types derived by restriction not supported. 
ConfigIndexOutOfRange=Configuration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains an index value '{0}' that is out of range.
ConfigMustSetTypeOrIndex=Configuration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains a 'parameter' element that has neither 'index' nor 'type' set. You must set one of these values.
ConfigMustOnlySetTypeOrIndex=Configuration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains a 'parameter' element that has both 'index' and 'type' set. You can only set one of these values.
ConfigMustOnlyAddParamsWithType=Configuration for known types (in the system.runtime.serialization section group, dataContractSerializer section) contains an invalid 'parameter' element. You can only add to its parameters collection when the 'type' property is set.
ConfigDataContractSerializerSectionLoadError=DataContractSerializer config section under System.Runtime.Serialization section group could not be loaded. Verify that machine.config is correctly set up.
CouldNotReadSerializationSchema=An internal error has occurred. Could not load serialization schema. Consider providing schema with namespace '{0}'.
DataContractCacheOverflow=An internal error has occurred. DataContract cache overflow.
DataContractNamespaceAlreadySet=ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.
DataContractNamespaceIsNotValid=DataContract namespace '{0}' is not a valid URI. 
DataContractNamespaceReserved=DataContract namespace '{0}' cannot be specified since it is reserved. 
DataMemberOnEnumField=Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead. 
DcTypeNotFoundOnDeserialize=Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider using a DataContractResolver if you are using DataContractSerializer or add the type corresponding to '{1}' to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding it to the list of known types passed to the serializer.
DcTypeNotFoundOnSerialize=Type '{0}' with data contract name '{1}:{2}' is not expected. Consider using a DataContractResolver if you are using DataContractSerializer or add any types not known statically to the list of known types - for example, by using the KnownTypeAttribute attribute or by adding them to the list of known types passed to the serializer.
DcTypeNotResolvedOnDeserialize=Element '{2}:{3}' contains data from a type that maps to the name '{0}:{1}'. The deserializer has no knowledge of any type that maps to this name. Consider changing the implementation of the ResolveName method on your DataContractResolver to return a non-null value for name '{1}' and namespace '{0}'.
DefaultOnElementNotSupported=Default value on element '{0}' is not supported.
DerivedTypeNotISerializable=It is not ISerializable but its base type '{0}' in namespace '{1}' is ISerializable.
DeserializedObjectWithIdNotFound=Deserialized object with reference id '{0}' not found in stream.
DupContractInDataContractSet=DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.
DupContractInKnownTypes=Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.
DupEnumMemberValue=Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.
DupKeyValueName=The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.
DupMemberName=Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.
DupTypeContractInDataContractSet=DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.
DuplicateAttribute=Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.
DuplicateCallback=Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.
DuplicateExtensionDataSetMethod=Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.
ElementMaxOccursMustBe='maxOccurs' on element '{0}' must be 1.
ElementMinOccursMustBe='minOccurs' on element '{0}' must be 0 or 1.
ElementRefOnLocalElementNotSupported=Ref to element '{0}' in '{1}' namespace is not supported.
EnumListInAnonymousTypeNotSupported=Anonymous type with <list> cannot be used to create Flags enumeration because it is not a valid enum type.
EnumListMustContainAnonymousType=Simple type list must contain an anonymous type specifying enumeration facets.
EnumOnlyEnumerationFacetsSupported=Facets other than enumeration facets are not supported.
EnumEnumerationFacetsMustHaveValue=Enumeration facets without 'value' are not supported.
EnumRestrictionInvalid=Anonymous type with <restriction> cannot be used to create Flags enumeration because it is not a valid enum type.
EnumTypeCannotBeImported=Enum type '{0}' in namespace '{1}' cannot be imported. {2}
EnumTypeCannotHaveIsReference=Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. 
EnumUnionInAnonymousTypeNotSupported=Anonymous type with <union>. cannot be used to create Flags enumeration because it is not a valid enum type.
ErrorInLine=Error in line {0} position {1}.
ErrorIsStartObject=There was an error checking start element of object {0}. {1}
ErrorDeserializing=There was an error deserializing the object {0}. {1}
ErrorSerializing=There was an error serializing the object {0}. {1}
ErrorWriteStartObject=There was an error writing start element of object {0}. {1}
ErrorWriteEndObject=There was an error writing end element of object {0}. {1}
ErrorTypeInfo=of type {0}
ExceededMaxItemsQuota=Maximum number of items that can be serialized or deserialized in an object graph is '{0}'. Change the object graph or increase the MaxItemsInObjectGraph quota. 
ExpectingElement=Expecting element '{1}' from namespace '{0}'.
ExpectingElementAtDeserialize=Expecting state '{0}' when ReadObject is called.
ExpectingEnd=Expecting End'{0}'.
ExpectingState=Expecting state '{0}'.
EncounteredWithNameNamespace={0}. Encountered '{1}'  with name '{2}', namespace '{3}'. 
FactoryObjectContainsSelfReference=Object graph of type '{0}' with Id '{2}' contains a reference to itself. The object has been replaced with a new object of type '{1}' either because it implements IObjectReference or because it is surrogated. The serializer does not support fixing up the nested reference to the new object and cannot deserialize this object. Consider changing the object to remove the nested self-reference.
FactoryTypeNotISerializable=Factory type '{0}' for ISerializable type '{1}' must also be ISerializable.
FixedOnElementNotSupported=Fixed value on element '{0}' is not supported.
FormMustBeQualified=Form on element '{0}' must be qualified.
GenericAnnotationAttributeNotFound=Annotation for generic type '{0}' did not have attribute '{1}'.
GenericAnnotationForNestedLevelMustBeIncreasing=Nested level on annotation elements '{0}' from namespace '{1}' for generic type '{2}' must be in increasing order.
GenericAnnotationHasInvalidAttributeValue=Annotation element '{0}' from namespace '{1}' for generic type '{2}' has an invalid value '{3}' for attribute '{4}'. Expecting value to be of type '{5}'.
GenericAnnotationHasInvalidElement=Annotation for generic type '{2}' has an invalid element '{0}' from namespace '{1}'.
GenericNameBraceMismatch=The data contract name '{0}' for type '{1}' has a curly brace '{{' that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.
GenericParameterNotValid=In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.
GenericTypeNameMismatch=DataContract name '{0}' from namespace '{1}' does not match the generic name '{2}' from namespace '{3}'.
GenericTypeNotExportable=Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.
GetOnlyCollectionMustHaveAddMethod=Collection interface type '{0}' is being used as a get-only property and does not have an Add method. Consider adding a setter to the property or using a collection data contract that does have an Add method - for example IList or ICollection<T>.
GetRealObjectReturnedNull=An object of type '{0}' which implements IObjectReference returned null from its GetRealObject method. Change the GetRealObject implementation to return a non-null value. 
InconsistentIsReference=The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.
IsAnyCannotBeNull=A null value cannot be serialized at the top level for IXmlSerializable root type '{0}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.
IsAnyNotSupportedByNetDataContractSerializer=Root type '{0}' is not supported at the top level by NetDataContractSerializer since it is IXmlSerializable with IsAny=true and must write all its contents including the root element.
IsAnyCannotBeSerializedAsDerivedType=An object of type '{0}' cannot be serialized at the top level for IXmlSerializable root type '{1}' since its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.
IsAnyCannotHaveXmlRoot=Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.
ISerializableAssemblyNameSetToZero=Type '{0}' has set its ISerializable assembly name to "0". "0" is an invalid assembly name. Consider using the full name of mscorlib if you would like your type to be deserialized in that assembly.
ISerializableCannotHaveDataContract=Type '{0}' cannot be ISerializable and have DataContractAttribute attribute.
ISerializableContainsMoreThanOneItems=Its root sequence contains more than one particle.
ISerializableDerivedContainsOneOrMoreItems=Derived ISerializable types cannot contain any particles.
ISerializableDoesNotContainAny=It does not contain root sequence with a wildcard element <any>.
ISerializableMustRefFactoryTypeAttribute=It does not reference attribute '{0}' from namespace '{1}'. 
ISerializableTypeCannotBeImported=ISerializable type '{0}' in namespace '{1}' cannot be imported. '{2}'
ISerializableWildcardMaxOccursMustBe='maxOccurs' on the wildcard element must be '{0}'.
ISerializableWildcardMinOccursMustBe='minOccurs' on the wildcard element must be '{0}'.
ISerializableWildcardNamespaceInvalid=Namespace on the wildcard element must be '{0}'.
ISerializableWildcardProcessContentsInvalid=ProcessContents on the wildcard element must be '{0}'.
IndexedPropertyCannotBeSerialized=Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.
InterfaceTypeCannotBeCreated=Interface type '{0}' cannot be created. Consider replacing with a non-interface serializable type. 
InvalidAnnotationExpectingText=Annotation '{0}' from namespace '{1}' has an invalid element '{2}' from namespace '{3}'. Expecting text.
InvalidAssemblyFormat='{0}' is an invalid value for AssemblyFormat. Only FormatterAssemblyStyle.Full or FormatterAssemblyStyle.Simple are supported.
InvalidClassDerivation=Type '{0}' in namespace '{1}' cannot be used as the base type of a data contract type, because it itself does not have a data contract. Consider marking type '{0}' with the DataContractAttribute attribute.
InvalidClrNameGeneratedForISerializable=ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract name cannot be customized for ISerializable type and the generated name '{2}' does not match the expected name '{0}'. Check if the required name has been mapped to a different type or if it is an invalid CLR name which cannot be generated or if the type requires an outer type which is not present.
InvalidClrNamespaceGeneratedForISerializable=ISerializable type with data contract name '{0}' in namespace '{1}' cannot be imported. The data contract namespace cannot be customized for ISerializable types and the generated namespace '{3}' does not match the required CLR namespace '{2}'. Check if the required namespace has been mapped to a different data contract namespace and consider mapping it explicitly using the namespaces collection. 
InvalidCollectionContractItemName=Type '{0}' cannot have CollectionDataContractAttribute attribute ItemName set to null or empty string.
InvalidCollectionContractKeyName=Type '{0}' cannot have CollectionDataContractAttribute attribute KeyName set to null or empty string.
InvalidCollectionContractKeyNoDictionary=The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.
InvalidCollectionContractName=Type '{0}' cannot have CollectionDataContractAttribute attribute Name set to null or empty string.
InvalidCollectionContractNamespace=Type '{0}' cannot have CollectionDataContractAttribute attribute Namespace set to null.
InvalidCollectionDataContract=Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it
InvalidCollectionContractValueName=Type '{0}' cannot have CollectionDataContractAttribute attribute ValueName set to null or empty string.
InvalidCollectionContractValueNoDictionary=The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.
InvalidCollectionType=Type '{0}' is an invalid collection type since it
InvalidDataContractName=Type '{0}' cannot have DataContractAttribute attribute Name set to null or empty string.
InvalidDataContractNamespace=Type '{0}' cannot have DataContractAttribute attribute Namespace set to null.
InvalidDataMemberName=Member '{0}' in type '{1}' cannot have DataMemberAttribute attribute Name set to null or empty string.
InvalidDataNode='{0}' is an invalid data node when deserializing extension data.
InvalidEmitDefaultAnnotation=Annotation for element {0} in type {1} from namespace {2} specifies EmitDefaultValue as 'true'. This requires the element to be either nillable or the element's type must be a value type.
InvalidEnumBaseType=Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.
InvalidEnumMemberValue='{0}' in type '{1}' cannot have EnumMemberAttribute attribute Value set to null or empty string.
InvalidEnumValueOnWrite=Enum value '{0}' is invalid for type '{1}' and cannot be serialized. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.
InvalidEnumValueOnRead=Invalid enum value '{0}' cannot be deserialized into type '{1}'. Ensure that the necessary enum values are present and are marked with EnumMemberAttribute attribute if the type has DataContractAttribute attribute.
InvalidGetSchemaMethod=Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string. 
InvalidGlobalDataContractNamespace=CLR namespace '{0}' cannot have ContractNamespace set to null.
InvalidInclusivePrefixListCollection=The inclusive namespace prefix collection cannot contain null as one of the items.
InvalidISerializableDerivation=Cannot import type '{0}' in namespace '{1}' as its base type because derived type is ISerializable but the base type is not ISerializable.
InvalidIdDefinition=Invalid Id '{0}'. Must be positive integer.
InvalidKeyValueType=It is an invalid dictionary type. Element '{0}' must reference a complex type containing a sequence with two required elements. Either fix the schema or remove the IsDictionary annotation.
InvalidKeyValueTypeNamespace=It is an invalid dictionary type since element '{0}' references a type from a different namespace '{1}'. Either fix the schema or remove the IsDictionary annotation.
InvalidMember=Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.
InvalidLocalNameEmpty=The empty string is not a valid local name.
InvalidNodeType='{0}' is an invalid node type.
InvalidNonNullReturnValueByIsAny=Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.
InvalidPrimitiveType=Type '{0}' is not a valid serializable type.
InvalidRefDefinition=Invalid Ref '{0}'. Must be positive integer.
InvalidReturnTypeOnGetSchemaMethod=Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.
InvalidReturnSchemaOnGetSchemaMethod=Method '{0}.GetSchema()' must return a schema with a valid Id.
InvalidSizeDefinition=Invalid Size '{0}'. Must be non-negative integer.
InvalidStateInExtensionDataReader=An internal error has occurred. ExtensionDataReader is in an invalid state.
InvalidXmlDataContractName=XML data contract Name for type '{0}' cannot be set to null or empty string.
InvalidXmlDeserializingExtensionData=The XML encountered when deserializing extension data is invalid.
InvalidXsIdDefinition=Invalid Id '{0}'. Must not be null or empty.
InvalidXsRefDefinition=Invalid Ref '{0}'. Must not be null or empty.
InvalidXmlQualifiedNameValue=Invalid XmlQualifiedName format: '{0}'.  XmlQualifiedName must be a name or a name and namespace separated by a comma.
IsNotAssignableFrom=An internal error has occurred. '{0}' is not assignable from '{1}' - error generating code for serialization.
IsDictionaryFormattedIncorrectly='{0}' is an invalid value for IsDictionary annotation. {1}
IsRequiredDataMemberOnIsReferenceDataContractType='{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. 
IsValueTypeFormattedIncorrectly='{0}' is an invalid value for IsValueType annotation. {1}
IXmlSerializableCannotHaveCollectionDataContract=Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.
IXmlSerializableCannotHaveDataContract=Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.
IXmlSerializableIllegalOperation=This method cannot be called from IXmlSerializable implementations.
IXmlSerializableMustHaveDefaultConstructor=IXmlSerializable Type '{0}' must have default constructor.
IXmlSerializableWritePastSubTree=IXmlSerializable.WriteXml method of type '{0}' attempted to close too many tags.  Verify that the IXmlSerializable implementation is correct.
IXmlSerializableMissingEndElements=IXmlSerializable.WriteXml method of type '{0}' did not close all open tags. Verify that the IXmlSerializable implementation is correct.
PartialTrustIXmlSerializableTypeNotPublic=The IXmlSerializable type '{0}' is not serializable in partial trust because it is not public.
PartialTrustIXmlSerialzableNoPublicConstructor=The IXmlSerializable type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.
PartialTrustDataContractTypeNotPublic=The data contract type '{0}' is not serializable in partial trust because it is not public.
PartialTrustISerializableNoPublicConstructor=The ISerializable type '{0}' cannot be deserialized in partial trust because it does not have a public constructor with parameters (SerializationInfo, StreamingContext).
PartialTrustNonAttributedSerializableTypeNoPublicConstructor=The type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.
PartialTrustDataContractOnSerializingNotPublic=The data contract type '{0}' cannot be serialized in partial trust because the OnSerializing method '{1}' is not public.
PartialTrustDataContractOnSerializedNotPublic=The data contract type '{0}' cannot be serialized in partial trust because the OnSerialized method '{1}' is not public.
PartialTrustDataContractOnDeserializingNotPublic=The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserializing method '{1}' is not public.
PartialTrustDataContractOnDeserializedNotPublic=The data contract type '{0}' cannot be deserialized in partial trust because the OnDeserialized method '{1}' is not public.
PartialTrustDataContractFieldGetNotPublic=The data contract type '{0}' cannot be serialized in partial trust because the member '{1}' is not public.
PartialTrustDataContractFieldSetNotPublic=The data contract type '{0}' cannot be deserialized in partial trust because the member '{1}' is not public.
PartialTrustDataContractPropertyGetNotPublic=The data contract type '{0}' cannot be serialized in partial trust because the property '{1}' does not have a public getter.
PartialTrustDataContractPropertySetNotPublic=The data contract type '{0}' cannot be deserialized in partial trust because the property '{1}' does not have a public setter.
PartialTrustCollectionContractTypeNotPublic=The collection data contract type '{0}' is not serializable in partial trust because it is not public.
PartialTrustCollectionContractNoPublicConstructor=The collection data contract type '{0}' cannot be deserialized in partial trust because it does not have a public parameterless constructor.
PartialTrustCollectionContractAddMethodNotPublic=The collection data contract type '{0}' cannot be deserialized in partial trust because the method '{1}' is not public.
NonAttributedSerializableTypesMustHaveDefaultConstructor=The Type '{0}' must have a parameterless constructor.
AttributedTypesCannotInheritFromNonAttributedSerializableTypes=Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.
ClassDataContractReturnedForGetOnlyCollection=The use of type '{0}' as a get-only collection is not supported with NetDataContractSerializer.  Consider marking the type with the CollectionDataContractAttribute attribute or the SerializableAttribute attribute or adding a setter to the property.
IsReferenceGetOnlyCollectionsNotSupported=Object with reference id '{0}' cannot be assigned to the collection property of type '{1}' since the property is get-only.  Consider adding a setter to the property or ensure that the get-only collection property does not reference another object.
SurrogatesWithGetOnlyCollectionsNotSupported=Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'. 
SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser=Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}'. 
NullValueReturnedForGetOnlyCollection=The get-only collection of type '{0}' returned a null value.  The input stream contains collection items which cannot be added if the instance is null.  Consider initializing the collection in the getter.
KeyTypeCannotBeParsedInSimpleDictionary=The dictionary of type '{0}' cannot be deserialized as a simple dictionary because its key type '{1}' does not have a public static Parse method.
KnownTypeAttributeEmptyString=Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.
KnownTypeAttributeUnknownMethod=KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.
KnownTypeAttributeReturnType=KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable<Type>. Ensure that the method exists and has a valid signature.
KnownTypeAttributeOneScheme=Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.
KnownTypeAttributeValidMethodTypes=Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.
KnownTypeAttributeNoData=KnownTypeAttribute attribute on type '{0}' contains no data.
KnownTypeAttributeMethodNull=Method specified by KnownTypeAttribute attribute on type '{0}' returned null.
KnownTypeConfigObject=The type System.Object cannot be used as a declared type in config.
KnownTypeConfigClosedGenericDeclared=Declared type '{0}' in config cannot be a closed or partial generic type.
KnownTypeConfigGenericParamMismatch=The type '{0}' in config has '{1}' generic parameter(s) but '{2}' generic argument(s) were provided. The number of generic arguments must match the number of generic parameters.
KnownTypeConfigIndexOutOfBoundsZero=The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed.
KnownTypeConfigIndexOutOfBounds=The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed. Parameter index must be greater than or equal to 0 and less than '{1}'.
MaxArrayLengthExceeded=The maximum array length ({0}) has been exceeded while reading XML data for array of type '{1}'. 
MixedContentNotSupported=Complex type with mixed content is not supported.
MissingGetSchemaMethod=Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.
MissingSchemaType=Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.
MultipleIdDefinition=Invalid XML encountered. The same Id value '{0}' is defined more than once. Multiple objects cannot be deserialized using the same Id.
MustContainOnlyLocalElements=The root sequence must contain only local elements. Group ref, choice, any and nested sequences are not supported.
NameCannotBeNullOrEmpty=XmlQualifiedName.Name cannot be null or empty.
NoConversionPossibleTo=An internal error has occurred. No conversion is possible to '{0}' - error generating code for serialization.
NoGetMethodForProperty=No get method for property '{1}' in type '{0}'.
NoSetMethodForProperty=No set method for property '{1}' in type '{0}'.
NonOptionalFieldMemberOnIsReferenceSerializableType='{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.
NullKnownType=One of the known types provided to the serializer via '{0}' argument was invalid because it was null. All known types specified must be non-null values.
ObjectTableOverflow=An internal error has occurred. Object table overflow. This could be caused by serializing or deserializing extremely large object graphs.
OnlyDataContractTypesCanHaveExtensionData=Type '{0}' does not have DataContractAttribute attribute and therefore cannot support IExtensibleDataObject. 
OrderCannotBeNegative=Property 'Order' in DataMemberAttribute attribute cannot be a negative number.
OutParametersMustBeByRefTypeReceived=Out parameters must be ByRef. Type received: '{0}'.
ParameterCountMismatch=Invalid number of parameters to call method '{0}'. Expected '{1}' parameters, but '{2}' were provided.
QueryGeneratorPathToMemberNotFound=Cannot find a path to the member when generating the XPath query.
QuotaMustBePositive=Quota must be a positive value.
QuotaIsReadOnly=The '{0}' quota is readonly.
QuotaCopyReadOnly=Cannot copy XmlDictionaryReaderQuotas. Target is readonly.
ReadOnlyClassDeserialization={0} The class cannot be deserialized.
ReadOnlyCollectionDeserialization=Collection type '{0}' cannot be deserialized since it
RecursiveCollectionType=Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.
RedefineNotSupported=Redefine is not supported.
ReferencedBaseTypeDoesNotExist=Collection type cannot be generated for type '{0}' from namespace '{1}'. Rename the type to '{2}' in namespace '{3}' or reference an existing collection type that implements '{4}' or '{5}' which can be used as a base type for the generated collection.
ReferencedCollectionTypesCannotContainNull=ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.
ReferencedTypeDoesNotMatch=Referenced type '{0}' with data contract name '{1}' in namespace '{2}' cannot be used since it does not match imported DataContract. Need to exclude this type from referenced types.
ReferencedTypeMatchingMessage=(matching)
ReferencedTypeNotMatchingMessage=(not matching)
ReferencedTypesCannotContainNull=ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.
RequiredMemberMustBeEmitted=Member {0} in type {1} cannot be serialized. This exception is usually caused by trying to use a null value where a null value is not allowed. The '{0}' member is set to its default value (usually null or zero). The member's EmitDefault setting is 'false', indicating that the member should not be serialized. However, the member's IsRequired setting is 'true', indicating that it must be serialized. This conflict cannot be resolved.  Consider setting '{0}' to a non-default value. Alternatively, you can change the EmitDefaultValue property on the DataMemberAttribute attribute to true, or changing the IsRequired property to false.
RequiresClassDataContractToSetIsISerializable=Only classes can be generated as ISerializable. 
ResolveTypeReturnedFalse=An object of type '{0}' which derives from DataContractResolver returned false from its TryResolveType method when attempting to resolve the name for an object of type '{1}', indicating that the resolution failed. Change the TryResolveType implementation to return true.
ResolveTypeReturnedNull=An object of type '{0}' which derives from DataContractResolver returned a null typeName or typeNamespace but not both from its TryResolveType method when attempting to resolve the name for an object of type '{1}'. Change the TryResolveType implementation to return non-null values, or to return null values for both typeName and typeNamespace in order to serialize as the declared type.
RootParticleMustBeSequence=The root particle must be a sequence.
RootSequenceMaxOccursMustBe='maxOccurs' on the root sequence must be 1.
RootSequenceMustBeRequired='minOccurs' on the root sequence must be 1.
SerializationInfo_ConstructorNotFound=The constructor with parameters (SerializationInfo, StreamingContext) is not found in ISerializable type '{0}'.
SimpleContentNotSupported=Complex types with simple content extension are not supported.
SimpleTypeRestrictionDoesNotSpecifyBase=Simple type restriction must specify a base type.
SimpleTypeUnionNotSupported=Simple types with <union> content are not supported.
SpecifiedTypeNotFoundInSchema=Invalid type specified. Type with name '{0}' not found in schema with namespace '{1}'.
SubstitutionGroupOnElementNotSupported=Substitution group on element '{0}' is not supported.
SupportForMultidimensionalArraysNotPresent=Multi-dimensional arrays are not supported.
TooManyCollectionContracts=Type '{0}' has more than one CollectionDataContractAttribute attribute.
TooManyDataContracts=Type '{0}' has more than one DataContractAttribute attribute.
TooManyDataMembers=Member '{0}.{1}' has more than one DataMemberAttribute attribute.
TooManyEnumMembers=Member '{0}.{1}' has more than one EnumMemberAttribute attribute.
TooManyIgnoreDataMemberAttributes=Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.
TopLevelElementRepresentsDifferentType=The global element found in the schema with same name references a different type '{0}' in namespace '{1}'. Data contract types must have the same name as their root element name. Consider removing the global element or changing its type.
TraceCodeElementIgnored=An unrecognized element was encountered in the XML during deserialization which was ignored.
TraceCodeFactoryTypeNotFound=The deserializer has no knowledge of the type to use during deserialization. Consider adding the type specified as factory type in the XML to the list of known types - for example by using the KnownTypeAttribute attribute.
TraceCodeObjectWithLargeDepth=Writing an object with a recursive structure has limitations when it has large depth. Consider reducing the depth of the object.
TraceCodeWriteObjectBegin=Starting WriteObject
TraceCodeWriteObjectEnd=Finished WriteObject
TraceCodeWriteObjectContentBegin=Starting WriteObjectContent
TraceCodeWriteObjectContentEnd=Finished WriteObjectContent
TraceCodeReadObjectBegin=Starting ReadObject
TraceCodeReadObjectEnd=Finished ReadObject
TraceCodeXsdExportAnnotationFailed=Failed to export annotation during XSD export.
TraceCodeXsdExportBegin=Starting schema export
TraceCodeXsdExportDupItems=Encountered duplicate items when generating schemas during XSD export.
TraceCodeXsdExportEnd=Finished schema export
TraceCodeXsdExportError=Error on schema export
TraceCodeXsdImportAnnotationFailed=Failed to import annotation during XSD import.
TraceCodeXsdImportBegin=Starting schema import
TraceCodeXsdImportEnd=Finished schema import
TraceCodeXsdImportError=Error on schema import
TypeCannotBeForwardedFrom=Type '{0}' in assembly '{1}' cannot be forwarded safely from assembly '{2}' because assembly '{1}' is not fully trusted and the public key tokens don't match. Consider enabling unsafe type forwarding in configuration.
TypeCannotBeImported=Type '{0}' in namespace '{1}' cannot be imported. {2}
TypeCannotBeImportedHowToFix={0} Either change the schema so that the types can map to data contract types or use ImportXmlType or use a different serializer.
TypeHasNotBeenImported=Type '{0}' from namespace '{1}' has not been imported from schema. Consider first importing this type by calling one of the Import methods on XsdDataContractImporter.
TypeMustBeIXmlSerializable=Schema type '{2}' in namespace '{3}' must be imported as an XML type. Type '{0}' cannot be mapped to this schema type because it does not implement '{1}'.  Consider not adding type '{0}' to the list of referenced types or changing it to implement '{1}'.
TypeNotSerializable=Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.
TypeMustNotBeOpenGeneric=Type '{0}' is not a fully instantiated generic class.
TypeMustBeConcrete=Error while getting known types for Type '{0}'. The type must not be an open or partial generic class.
TypeShouldNotContainAttributes=Attributes must be optional and from namespace '{0}'.
UnexpectedContractType=An internal error has occurred. Unexpected contract type '{0}' for type '{1}' encountered. 
UnexpectedElementExpectingElements='{0}' '{1}' from namespace '{2}' is not expected. Expecting element '{3}'.
UnexpectedEndOfFile=Unexpected end of file.
UnknownConstantType=Unrecognized constant type '{0}'.
UnknownXmlType=Type '{0}' is not a valid XML type.
ExtensionDataSetMustReturnVoid=IExtensibleDataObject property setter '{1}' in type '{0}' must return void.
ExtensionDataSetParameterInvalid=IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.
ValueTypeCannotBeNull=ValueType '{0}' cannot be null.
ValueTypeCannotHaveBaseType=Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.
ValueTypeCannotHaveId=ValueType '{0}' cannot have id.
ValueTypeCannotHaveIsReference=Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely. 
ValueTypeCannotHaveRef=ValueType '{0}' cannot have ref to another object.
XmlForObjectCannotHaveContent=Element {0} from namespace {1} cannot have child contents to be deserialized as an object. Please use XmlNode[] to deserialize this pattern of XML.
XmlFoundElement=element '{0}' from namespace '{1}'
XmlFoundEndElement=end element '{0}' from namespace '{1}'
XmlFoundText=text '{0}'
XmlFoundCData=cdata '{0}'
XmlFoundComment=comment '{0}'
XmlFoundEndOfFile=end of file
XmlFoundNodeType=node {0}
XmlCloseCData=']]>' not valid in text node content.
XmlStartElementExpected=Start element expected. Found {0}.
XmlStartElementNameExpected=Start element '{0}' expected. Found {1}.
XmlStartElementLocalNameNsExpected=Start element '{0}' from namespace '{1}' expected. Found {2}.
XmlFullStartElementExpected=Non-empty start element expected. Found {0}.
XmlFullStartElementNameExpected=Non-empty start element '{0}' expected. Found {1}.
XmlFullStartElementLocalNameNsExpected=Non-empty start element '{0}' from namespace '{1}' expected. Found {2}.
XmlEndElementExpected=End element '{0}' from namespace '{1}' expected. Found {2}.
XmlMaxDepthExceeded=The maximum read depth ({0}) has been exceeded because XML data being read has more levels of nesting than is allowed by the quota. This quota may be increased by changing the MaxDepth property on the XmlDictionaryReaderQuotas object used when creating the XML reader.
XmlMaxStringContentLengthExceeded=The maximum string content length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxStringContentLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.
XmlMaxArrayLengthExceeded=The maximum array length quota ({0}) has been exceeded while reading XML data. This quota may be increased by changing the MaxArrayLength property on the XmlDictionaryReaderQuotas object used when creating the XML reader.
XmlMaxArrayLengthOrMaxItemsQuotaExceeded=The maximum array length quota ({0}) or the maximum items in object graph quota has been exceeded while reading XML data. These quotas may be increased by changing the MaxArrayLength property on XmlDictionaryReaderQuotas or the MaxItemsInObjectGraph setting.
XmlMaxBytesPerReadExceeded=The 'maximum bytes per Read operation' quota ({0}) has been exceeded while reading XML data. Long element start tags (consisting of the element name, attribute names and attribute values) may trigger this quota. This quota may be increased by changing the MaxBytesPerRead property on the XmlDictionaryReaderQuotas object used when creating the XML reader.
XmlMaxNameTableCharCountExceeded=The maximum nametable character count quota ({0}) has been exceeded while reading XML data. The nametable is a data structure used to store strings encountered during XML processing - long XML documents with non-repeating element names, attribute names and attribute values may trigger this quota. This quota may be increased by changing the MaxNameTableCharCount property on the XmlDictionaryReaderQuotas object used when creating the XML reader.
XmlBase64DataExpected=Base64 encoded data expected. Found {0}.
XmlUndefinedPrefix=The prefix '{0}' is not defined.
XmlProcessingInstructionNotSupported=Processing instructions (other than the XML declaration) and DTDs are not supported.
XmlUnexpectedEndOfFile=Unexpected end of file. Following elements are not closed: {0}.
XmlUnexpectedEndElement=No matching start tag for end element.
XmlDuplicateAttribute=Duplicate attribute found. Both '{0}' and '{1}' are from the namespace '{2}'.
XmlInvalidFormat=The input source is not correctly formatted.
XmlTokenExpected=The token '{0}' was expected but found '{1}'.
XmlTagMismatch=Start element '{0}' does not match end element '{1}'.
XmlDeclNotFirst=No characters can appear before the XML declaration.
XmlConversionOverflow=The value '{0}' cannot be represented with the type '{1}'.
XmlInvalidConversion=The value '{0}' cannot be parsed as the type '{1}'.
XmlInvalidUTF8Bytes='{0}' contains invalid UTF8 bytes.
XmlInvalidBytes=Invalid byte encoding.
XmlEmptyNamespaceRequiresNullPrefix=The empty namespace requires a null or empty prefix.
XmlInvalidCharRef=Character reference not valid.
XmlInvalidFFFE=Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.
XmlInvalidCommentChars=XML comments cannot contain '--' or end with '-'.
XmlInvalidDepth=Cannot call '{0}' while Depth is '{1}'.
XmlInvalidHighSurrogate=High surrogate char '0x{0}' not valid. High surrogate chars range from 0xD800 to 0xDBFF.
XmlInvalidLowSurrogate=Low surrogate char '0x{0}' not valid. Low surrogate chars range from 0xDC00 to 0xDFFF.
XmlInvalidSurrogate=Surrogate char '0x{0}' not valid. Surrogate chars range from 0x10000 to 0x10FFFF.
XmlMissingLowSurrogate=The surrogate pair is invalid. Missing a low surrogate character.
XmlInvalidID=ID must be >= 0.
XmlInvalidOperation=The reader cannot be advanced.
XmlEndElementNoOpenNodes=No corresponding start element is open.
XmlInvalidPrefixState=A prefix cannot be defined while WriteState is '{0}'.
XmlInvalidRootData=The data at the root level is invalid.
XmlInvalidWriteState='{0}' cannot be called while WriteState is '{1}'.
XmlInvalidXmlSpace='{0}' is not a valid xml:space value. Valid values are 'default' and 'preserve'.
XmlInvalidXmlByte=The byte 0x{0} is not valid at this location. 
XmlIDDefined=ID already defined.
XmlKeyAlreadyExists=The specified key already exists in the dictionary.
XmlLineInfo=Line {0}, position {1}.
XmlMethodNotSupported=This XmlWriter implementation does not support the '{0}' method.
XmlMultipleRootElements=There are multiple root elements.
XmlWriteFunctionInvalid='{0}' is not valid for a SOAP message.
XmlInvalidDeclaration=XML declaration can only be written at the beginning of the document.
XmlPrefixBoundToNamespace=The prefix '{0}' is bound to the namespace '{1}' and cannot be changed to '{2}'.
XmlReservedPrefix=Prefixes beginning with "xml" (regardless of casing) are reserved for use by XML.
XmlNamespaceNotFound=The namespace '{0}' is not defined.
XmlSpecificBindingNamespace=The namespace '{1}' can only be bound to the prefix '{0}'.
XmlSpecificBindingPrefix=The prefix '{0}' can only be bound to the namespace '{1}'.
XmlOnlyWhitespace=Only white space characters can be written with this method.
XmlWriterMustBeInElement=WriteState '{0}' not valid. Caller must write start element before serializing in contentOnly mode.
XmlOnlySingleValue=Only a single typed value may be written inside an attribute or content.
XmlWriterClosed=The XmlWriter is closed.
XmlInvalidVersion=XML version must be '1.0'.
XmlInvalidEncoding=XML encoding must be 'UTF-8'.
XmlEncodingNotSupported=XML encoding not supported.
XmlInvalidStandalone='standalone' value in declaration must be 'yes' or 'no'.
XmlSpaceBetweenAttributes=Whitespace must appear between attributes.
XmlCDATAInvalidAtTopLevel=CData elements not valid at top level of an XML document.
XmlEncodingMismatch=The encoding in the declaration '{0}' does not match the encoding of the document '{1}'.
XmlMalformedDecl=Malformed XML declaration.
XmlExpectedEncoding=The expected encoding '{0}' does not match the actual encoding '{1}'.
XmlDeclarationRequired=An XML declaration with an encoding is required for all non-UTF8 documents.
XmlDeclMissingVersion=Version not found in XML declaration.
XmlDeclMissing=An XML declaration is required for all non-UTF8 documents.
XmlBadBOM=Unrecognized Byte Order Mark.
XmlNoRootElement=The document does not have a root element.
XmlIllegalOutsideRoot=Text cannot be written outside the root element.
XmlOnlyOneRoot=Only one root element is permitted per document.
XmlInvalidBase64Sequence=The characters '{0}' at offset {1} are not a valid Base64 sequence.
XmlInvalidBase64Length=Base64 sequence length ({0}) not valid. Must be a multiple of 4.
XmlInvalidBinHexSequence=The characters '{0}' at offset {1} are not a valid BinHex sequence.
XmlInvalidBinHexLength=BinHex sequence length ({0}) not valid. Must be a multiple of 2.
XmlArrayTooSmall=Array too small.
XmlArrayTooSmallInput=Array too small.  Length of available data must be at least {0}.
XmlArrayTooSmallOutput=Array too small.  Must be able to hold at least {0}.
XmlInvalidQualifiedName=Expected XML qualified name. Found '{0}'.
XmlInvalidUniqueId=UniqueId cannot be zero length.
XmlInvalidStream=Stream returned by IStreamProvider cannot be null.
XmlNestedArraysNotSupported=Nested arrays are not supported.
XmlCanonicalizationStarted=Canonicalization already started.
XmlCanonicalizationNotStarted=Canonicalization not started.
XmlElementAttributes=Only Element nodes have attributes.
ValueMustBeNonNegative=The value of this argument must be non-negative.
OffsetExceedsBufferSize=The specified offset exceeds the buffer size ({0} bytes).
SizeExceedsRemainingBufferSpace=The specified size exceeds the remaining buffer space ({0} bytes).
XmlDictionaryStringIDRange=XmlDictionaryString IDs must be in the range from {0} to {1}.
XmlDictionaryStringIDUndefinedSession=XmlDictionaryString ID {0} not defined in the XmlBinaryReaderSession.
XmlDictionaryStringIDUndefinedStatic=XmlDictionaryString ID {0} not defined in the static dictionary.
ValueMustBeInRange=The value of this argument must fall within the range {0} to {1}.
CombinedPrefixNSLength=The combined length of the prefix and namespace must not be greater than {0}.
FlushBufferAlreadyInUse=Cannot write to a buffer which is currently being flushed.
NoAsyncWritePending=There is no pending asynchronous write on this stream. Ensure that there is pending write on the stream or verify that the implementation does not try to complete the same operation multiple times.
;
; MTOM strings
;
MimeContentTypeHeaderInvalid=Invalid MIME content-type header encountered on read.
MimeHeaderInvalidCharacter=Character '{0}' (hexadecimal value 0x{1}) not valid in MIME header.
MimeMessageGetContentStreamCalledAlready=Content stream can be retrieved from MIME message only once.
MaxMimePartsExceeded=The number of MIME parts in the MTOM message exceeded the current quota '{0}'. To increase the quota, change the '{1}' setting in the AppSettings section of the configuration file.
MimeReaderHeaderAlreadyExists='{0}' MIME header is specified multiple times.
MimeReaderMalformedHeader=Malformed header.
MimeReaderResetCalledBeforeEOF=Reset called on MIME header reader before end of file.
MimeReaderTruncated=Unexpected end of file.
MimeVersionHeaderInvalid=Invalid mime-version header encountered on read.
MimeWriterInvalidStateForClose=Cannot call Close on MIME writer in state '{0}'.
MimeWriterInvalidStateForHeader=MIME writer cannot write MIME header in state '{0}'.
MimeWriterInvalidStateForContent=MIME writer cannot write content in state '{0}'.
MimeWriterInvalidStateForStartPart=MIME writer cannot start new MIME part in state '{0}'.
MimeWriterInvalidStateForStartPreface=MIME writer cannot start preface in '{0}' state.
MtomBoundaryInvalid='{0}' not a valid MIME boundary.
MtomBufferQuotaExceeded=The maximum buffer size ({0}) has been exceeded while reading MTOM data. This quota may be increased by changing the maxBufferSize setting used when creating the MTOM reader.
MtomContentTransferEncodingNotPresent=Content-Transfer-Encoding header with value '{0}' must be present for binary part.
MtomContentTransferEncodingNotSupported='{0}' Content-Transfer-Encoding not supported for infoset. Must be one of '{1}', '{2}', or '{3}'.
MtomContentTypeInvalid=contentType must be non-zero length string.
MtomDataMustNotContainXopInclude=XML data contained in MTOM messages must not contain element with name '{0}' from namespace '{1}'.
MtomExceededMaxSizeInBytes=The 'maximum size in bytes' quota ({0}) has been exceeded while writing MTOM data. This quota may be increased by changing the maxSizeInBytes setting used when creating the MTOM writer.
MtomInvalidCIDUri=Invalid URI '{0}' specified for MIME part Content-ID is not conformant cid URI.
MtomInvalidEmptyURI=URI specified for MIME part Content-ID cannot be empty.
MtomInvalidStartUri=Invalid start URI for infoset '{0}'.
MtomInvalidTransferEncodingForMimePart=Content-Transfer-Encoding '{0}' not supported for binary part. Must be '{1}'.
MtomMessageContentTypeNotFound=Content-Type header for MTOM message not found. 
MtomMessageInvalidContent=MTOM message not valid. Does not contain correctly formatted content following headers.
MtomMessageInvalidContentInMimePart=MTOM message not valid. One or more MIME parts in the message does not contain correctly formatted content and/or boundary string.
MtomMessageInvalidMimeVersion='{0}' not a valid MIME version. MTOM messages must have MIME version '{1}'.
MtomMessageNotApplicationXopXml=MTOM messages must have type '{0}'.
MtomMessageNotMultipart=MTOM messages must have media type '{0}' and media subtype '{1}'.
MtomMessageRequiredParamNotSpecified=MTOM messages must have non-zero length '{0}' parameter in Content-Type header.
MtomMimePartReferencedMoreThanOnce=MTOM message not valid. Infoset references MIME part with Content-ID '{0}' more than once.
MtomPartNotFound=MIME part with Content-ID '{0}' not found.
MtomRootContentTypeNotFound=Content-Type header for root MIME part not found.
MtomRootNotApplicationXopXml=Root MIME part must have media type '{0}' and media subtype '{1}'.
MtomRootPartNotFound=Root MIME part containing infoset not found.
MtomRootRequiredParamNotSpecified=Root MIME part must contain non-zero length value for '{0}' parameter in Content-Type header.
MtomRootUnexpectedCharset=Unexpected charset '{0}' found in root MIME part. Expecting '{1}'.
MtomRootUnexpectedType=Unexpected type '{0}' found in root MIME part. Message header specifies '{1}'.
MtomXopIncludeHrefNotSpecified=Mandatory attribute '{0}' not found on XOP Include element.
MtomXopIncludeInvalidXopAttributes=XOP Include element has invalid attribute '{0}' from XOP namespace '{1}'.
MtomXopIncludeInvalidXopElement=XOP Include element has invalid child element '{0}' from XOP namespace '{1}'.
ReadNotSupportedOnStream=Read not supported on stream '{0}'.
SeekNotSupportedOnStream=Seek not supported on stream '{0}'.
WriteBufferOverflow=An internal error has occurred. Overflow on MIME writer buffer.
WriteNotSupportedOnStream=Write not supported on stream '{0}'.
; 
; JSON strings
;
JsonOnlyWhitespace=Unexpected character '{0}'. '{1}' can write only white space characters.
JsonInvalidStartElementCall=WriteStartElement can be called at only the start of a document or immediately after calling WriteEndElement.
JsonNodeTypeArrayOrObjectNotSpecified=WriteStartElement cannot be called immediately after WriteStartElement without writing the 'type'='array' or 'type='object' attribute.
JsonInvalidLocalNameEmpty=The empty string is not a valid local name in JSON.
JsonMustSpecifyDataType=You must write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'.
JsonAttributeAlreadyWritten=Cannot write attribute with local name '{0}' multiple times.
JsonSizeExceedsRemainingBufferSpace=The specified size exceeds the remaining buffer space ('{0}' bytes).
JsonEndElementNoOpenNodes=No corresponding start element is open.
JsonNoMatchingStartAttribute=There is no open attribute.
JsonWriterClosed=The writer is closed.
JsonCannotWriteStandaloneTextAfterQuotedText=Cannot write a CLR value that maps to number, array, object, true, false or null in JSON after a string value has been written.
JsonOffsetExceedsBufferSize=The specified offset exceeds the buffer size ({0} bytes).
JsonEncounteredUnexpectedCharacter=Encountered unexpected character '{0}'.
JsonInvalidBytes=Invalid byte encoding.
JsonEncodingNotSupported=Encoding not supported in JSON. UTF-8, Unicode, and BigEndianUnicode are the only supported encodings.
JsonUnexpectedEndOfFile=Unexpected end of file.
JsonValueMustBeInRange=The value of this argument must fall within the range {0} to {1}.
JsonDuplicateMemberNames=The data contract type '{0}' is not serializable with DataContractJsonSerializer because the data member '{1}' is duplicated in its type hierarchy.
JsonDuplicateMemberInInput=The data contract type '{0}' cannot be deserialized because the data member '{1}' was found more than once in the input.
JsonRequiredMembersNotFound=The data contract type '{0}' cannot be deserialized because the required data members '{1}' were not found.
JsonOneRequiredMemberNotFound=The data contract type '{0}' cannot be deserialized because the required data member '{1}' was not found.
JsonInvalidWriteStat='{0}' cannot be called while WriteState is '{1}'.
JsonInvalidDateTimeString=DateTime content '{0}' does not start with '{1}' and end with '{2}' as required for JSON.
JsonExpectedEncoding=The expected encoding '{0}' does not match the actual encoding '{1}'.
JsonOpenAttributeMustBeClosedFirst=Cannot call {0} while an attribute is being written.
JsonTypeNotSupportedByDataContractJsonSerializer=DataContractJsonSerializer does not support objects of type '{0}'.
EnumTypeNotSupportedByDataContractJsonSerializer=DataContractJsonSerializer does not support data members of type '{0}'.  Consider using int, System.Object, or a concrete enum definition instead.
JsonNamespaceMustBeEmpty=Encountered unexpected namespace '{0}'. The namespace must be empty.
ChangingFullTypeNameNotSupported=DataContractJsonSerializer does not support the setting of the FullTypeName of the object to be serialized to a value other than the default FullTypeName. Attempted to serialize object with full type name '{0}' and default full type name '{1}'.
JsonXmlProcessingInstructionNotSupported=Processing instructions (other than the XML declaration) are not supported.
JsonXmlInvalidDeclaration=XML declaration can only be written at the beginning of the document.
JsonMultipleRootElementsNotAllowedOnWriter=This XmlDictionaryWriter implementation does not support the writing of multiple root elements.
JsonInvalidMethodBetweenStartEndAttribute=Cannot write content while an attribute is being written.
JsonServerTypeSpecifiedForInvalidDataType=Attempted to write an attribute with local name '{0}' after writing the attribute '{1}'='{2}'. An attribute with local name '{0}' may be written only after writing the attribute '{1}'='{3}'.
JsonInvalidDataTypeSpecifiedForServerType=Attempted to write an attribute '{0}'='{1}' after writing the attribute with local name '{2}'. The attribute with local name '{2}' is only valid with an attribute '{0}'='{3}'.
JsonUnexpectedAttributeValue=The attribute 'type' must have one of the following strings as its values: 'string', 'number', 'array', 'object', 'null', or 'boolean'.  Encountered unexpected value '{0}'
JsonPrefixMustBeNullOrEmpty=Encountered unexpected prefix '{0}'. The prefix must be null or empty.
JsonUnexpectedAttributeLocalName=Encountered unexpected attribute local name '{0}'. 'type' and '__type' are the only allowed local names for attributes. 'type' can be used to influence how data is written; its valid values are 'object', 'string', 'number', 'null', 'boolean', and 'array'. '__type' can be used to provide type hint information to the writer.
JsonCannotWriteTextAfterNonTextAttribute=Attempted to write text after writing attribute type='{0}'. Text may be written only after the attributes type='number', type='boolean', or type='string'.
JsonInvalidItemNameForArrayElement=Encountered unexpected element local name '{0}' for item in collection. '{1}' is the only valid local name for elements in a collection.
JsonInvalidRootElementName=Encountered invalid root element name '{0}'. '{1}' is the only allowed root element name.
JsonAttributeMustHaveElement=WriteStartElement must be called at least once before WriteStartAttribute may be called.
JsonNestedArraysNotSupported=Nested arrays are not supported.
JsonMethodNotSupported=This XmlDictionaryWriter implementation does not support the '{0}' method.
JsonInvalidFFFE=Characters with hexadecimal values 0xFFFE and 0xFFFF are not valid.
JsonUnsupportedForIsReference=The type '{0}' cannot be serialized to JSON because its IsReference setting is '{1}'. The JSON format does not support references because there is no standardized format for representing references. To enable serialization, disable the IsReference setting on the type or an appropriate parent class of the type.
JsonMustUseWriteStringForWritingAttributeValues=To write attribute values with this XmlDictionaryWriter implementation, you must write either string or char[] values.
JsonWriteArrayNotSupported=To write JSON arrays, use XML writer methods to write the attribute type="array" followed by methods like WriteStartElement (with the local name "item"), WriteAttributeString, and WriteEndElement to write the JSON array items.
JsonDateTimeOutOfRange=DateTime values that are greater than DateTime.MaxValue or smaller than DateTime.MinValue when converted to UTC cannot be serialized to JSON.
XmlObjectAssignedToIncompatibleInterface='{0}' is an XML type and cannot be serialized when assigned to an interface type that does not implement IXmlSerializable ('{1}'.)
CollectionAssignedToIncompatibleInterface='{0}' is a collection type and cannot be serialized when assigned to an interface type that does not implement IEnumerable ('{1}'.)
InvalidCharacterEncountered=Encountered invalid character '{0}'.
JsonInvalidWriteState='{0}' cannot be called while WriteState is '{1}'.
InvalidAsyncResult=The asynchronous result object used to end this operation was not the object that was returned when the operation was initiated.